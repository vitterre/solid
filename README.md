# Принципы SOLID

### Сами принципы:
1.	**SRP**: Single Responsibility Principle.
2.	**OCP**: Open-Closed Principle.
3.	**LSP**: Liskov Substitution Principle.
4.	**ISP**: Interface Segregation Principle.
5.	**DIP**: Dependency Inversion Principle.

### LSP: Liskov Substitution Principle.
Замена экземпляров классов на экземпляры их подклассов (наследников) не должна влиять на правильность работы программы.
Подтипы должны дополнять базовые типы.

### Признаки нарушения:
1.	**Дочерний класс замещает или изменяет поведение родительского класса.**
2.	**При подстановке родительского класса на дочерний или другие дочерние приходится менять программу.**

### Пример
У нас есть класс базы данных `DataBase` с классическими операциями. На данным этапе мы плохо продумали архитектуру и добавляем еще один метод, который позволяет нам объединять таблицы.

Потом мы создаем класс `MySQLDataBase`, который наследуется от предыдущего и как-то по своему реализует методы, в том числе и `joinTables()`. MySQL - это реляционная база данных, в которой все данные хранятся в форме связанных таблиц. Поэтому данный метод тут уместен.

Позже в проект приезжает MongoDB, не реляционная база данных, в которой нет таблиц, данные хранятся в форме коллекций и документов. Нет таблиц - объединять то и нечего. Значит метод `joinTables()` бесполезен. Пусть он будет выкидывать ошибку.

Понятно, чем это грозит. У нас в приложении где-то настраивается БД, подключаемся к ней. Сначала использовали MySQL, все работало, потом поменяли на MongoDB, и у нас где-то вылетает ошибка.

Как исправить? Удаляем у родительского класса метод, в котором выкидывается ошибка. Создаем еще два класса: `SQLDataBase`, работающий с реляционными БД, и `NOSQLDataBase`, работающий с не реляционными БД. Первый класс содержит метод `joinTables()` по вполне логичным причинам. Второй его не имеет, он содержит другие методы.

От этих двух классов уже наследуются интересующие нас БД. Таким образом, базовый класс содержит операции, которые есть в каждом классе. Они могут быть изменены, но они не будут нарушать логику приложения. Дочерние классы лишь расширяют функционал.