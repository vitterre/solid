# Принципы SOLID

### Сами принципы:
1.	**SRP**: Single Responsibility Principle.
2.	**OCP**: Open-Closed Principle.
3.	**LSP**: Liskov Substitution Principle.
4.	**ISP**: Interface Segregation Principle.
5.	**DIP**: Dependency Inversion Principle.

### OCP: Open-Closed Principle.
Программные сущности должны быть открыты для расширения и закрыты для изменения.
Должна быть возможность изменять внешнее поведение класса, не внося изменения в сам класс.

### Признаки нарушения:
1. **Одно изменение в коде влечет за собой каскад других изменений.**
2. **Регрессионное тестирование**.

### Пример
Самый простой пример нарушения принципа открытости/закрытости – использование конкретных объектов без абстракций. Предположим, что у нас есть объект `SmtpMailer`. Для логирования своих действий он использует `FileLogger`, который записывает информацию в текстовые файлы.

И то же самое происходит в других классах, которые используют `FileLogger`. Такая конструкция вполне жизнеспособна до тех, пока мы не решим записывать лог `SmptMailer`'a в базу данных. Для этого нам надо создать класс `DataBaseLogger`, который будет записывать все логи не в текстовый файл, а в базу данных.

А теперь самое интересное. Мы должны изменить класс `SmptMailer` из-за изменившегося бизнес-требования, но мы не можем этого сделать! Этот класс содержит методы, которые уже давным-давно были написаны и протестированы. Если мы изменим конкретный метод, то вполне возможно, что мы получим эффект снежного кома, когда одно изменение влечет за собой каскад других изменений.

Как это решить? В данном случае защитить `SmtpMailer` поможет выделение абстракции. Пусть `SmtpMailer` зависит от интерфейса `ILogger`. А остальные вышеупомянутые классы будут реализовывать этот интерфейс.