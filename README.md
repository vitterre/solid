# Принципы SOLID

### Сами принципы:
1.	**SRP**: Single Responsibility Principle.
2.	**OCP**: Open-Closed Principle.
3.	**LSP**: Liskov Substitution Principle.
4.	**ISP**: Interface Segregation Principle.
5.	**DIP**: Dependency Inversion Principle.

### DIP: Dependency Inversion Principle.
Код, реализующий высокоуровневую политику, не должен зависеть от кода, реализующего низкоуровневые детали. Напротив, детали должны зависеть от политики.

Зависимости внутри системы строятся на уровне абстракций. Модули верхнего уровня не зависят от модулей нижнего уровня. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
Инструкции вида use, import и include должны ссылаться только на модули с исходным кодов, содержащим интерфейсы, абстрактные классы и другие абстрактные объявления.

**Сильное зацепление** – использование в качестве зависимостей конкретные реализации.

**Слабое зацепление** – зависимость на уровне абстракций.

### Признаки нарушения:
1.	**Ссылка на изменчивые конкретные классы.**
2.	**Наследование изменчивых конкретных классов.**
3.	**Переопределение конкретных методов.**
4.	**Ссылка на имена конкретных и изменчивых сущностей.**
5.	**Изменение одной части кода затрагивает слишком много других частей.**
6.	**Никакая из частей приложения не может быть легко выделена и повторно использована.** 

### Пример
У нас есть какое-то приложение, ведущее учет программистов, которые работают над каким-то приложением.

Вот у нас есть абстрактный класс `App`. От него наследуется уже конкретика - класс `WebApp`. И `Developer` по сути "зависит от зависимости", ведь `WebApp` - дочерний класс `App`, который зависит от того, как будет вести себя его родитель.

Как исправить? Добавить, например, конструктор в классе разработчика, который принимает некий экземпляр класса `App`. И здесь он уже будет в конкретном случае принимать конкретное значение.